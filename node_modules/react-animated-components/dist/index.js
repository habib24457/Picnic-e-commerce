Object.defineProperty(exports, '__esModule', { value: true });

var styled = require('styled-components');
var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/**
 * Fades
 */
const fadeIn = styled.keyframes `
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
const fadeOut = styled.keyframes `
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
`;
/**
 * Rotations
 */
const rotateCw = styled.keyframes `
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(359deg);
  }
`;
const rotateCcw = styled.keyframes `
  from {
    transform: rotate(359deg);
  }
  to {
    transform: rotate(0deg);
  }
`;
/**
 * Slides
 */
const slideInDown = styled.keyframes `
  from {
    transform: translate3d(0, -100%, 0);
    visibility: visible;
  }
  to {
    transform: translate3d(0, 0, 0);
  }
`;
const slideInUp = styled.keyframes `
  from {
    transform: translate3d(0, 100%, 0);
    visibility: visible;
  }
  to {
    transform: translate3d(0, 0, 0);
  }
`;
const slideInRight = styled.keyframes `
  from {
    transform: translate3d(-100%, 0, 0);
    visibility: visible;
  }
  to {
    transform: translate3d(0, 0, 0);
  }
`;
const slideInLeft = styled.keyframes `
  from {
    transform: translate3d(100%, 0, 0);
    visibility: visible;
  }
  to {
    transform: translate3d(0, 0, 0);
  }
`;
const slideOutDown = styled.keyframes `
  from {
    transform: translate3d(0, 0, 0);
  }
  to {
    visibility: hidden;
    transform: translate3d(0, 100%, 0);
  }
`;
const slideOutUp = styled.keyframes `
  from {
    transform: translate3d(0, 0, 0);
  }
  to {
    visibility: hidden;
    transform: translate3d(0, -100%, 0);
  }
`;
const slideOutRight = styled.keyframes `
  from {
    transform: translate3d(0, 0, 0);
  }
  to {
    visibility: hidden;
    transform: translate3d(100%, 0, 0);
  }
`;
const slideOutLeft = styled.keyframes `
  from {
    transform: translate3d(0, 0, 0);
  }
  to {
    visibility: hidden;
    transform: translate3d(-100%, 0, 0);
  }
`;
/**
 * Wipes
 */
const wipeOutY = (props) => {
    return styled.keyframes `
  from {
    height: ${props.heightPx}px;
   }
   to {
    height: 0px;
    visibility: hidden;
   }
  `;
};
const wipeOutX = (props) => {
    return styled.keyframes `
  from {
    width: ${props.widthPx}px;
   }
   to {
    width: 0px;
    visibility: hidden;
   }
  `;
};
const wipeInY = (props) => {
    return styled.keyframes `
  0% {
    visibility: hidden;
    position: absolute;
    z-index: -999;
    left: -2000px;
    bottom: -2000px;
  }
  1% {
    height: 0px;
    position: relative;
    visibility: visible;
  }
  100% {
     height: ${props.heightPx}px;
   }
  `;
};
const wipeInX = (props) => {
    return styled.keyframes `
  0% {
    visibility: hidden;
    position: absolute;
    z-index: -999;
    left: -2000px;
    bottom: -2000px;
  }
  1% {
    width: 0px;
    position: relative;
    visibility: visible;
  }
  100% {
    width: ${props.widthPx}px;
   }
  `;
};

const config = {
    durationMs: {
        fast: 500,
        medium: 1000,
        slow: 2000,
    },
    timingFunc: {
        linear: 'linear',
        easeIn: 'ease-in',
        easeOut: 'ease-out',
        easeInOut: 'ease-in-out',
    },
    fillModes: {
        default: 'none',
        exitAnimationDefault: 'forwards',
        enterAnimationDefault: 'backwards',
    },
    iterations: {
        once: 1,
        infinite: 'infinite',
    },
    components: {
        default: styled__default['default'].div `
      overflow: clip;
      box-sizing: border-box;
    `,
    },
};

/**
 * Factory function to configure and return an animated function component.
 */
const animationFactory = ({ keyframes, component, defaultDurationMs, defaultTimingFunc, defaultIterations, defaultExitOnComplete, defaultActive, defaultDelayMs, defaultFillMode, }) => {
    component = component || config.components.default;
    defaultActive = defaultActive !== undefined ? !!defaultActive : true;
    defaultDurationMs = defaultDurationMs || config.durationMs.slow;
    defaultTimingFunc = defaultTimingFunc || config.timingFunc.linear;
    defaultIterations = defaultIterations || config.iterations.once;
    defaultFillMode = defaultFillMode || config.fillModes.default;
    defaultDelayMs = defaultDelayMs || 0;
    const componentCss = styled.css `
    animation-name: ${(props) => (typeof keyframes === 'function' ? keyframes(props) : keyframes)};
    animation-duration: ${(props) => props.durationMs || defaultDurationMs}ms;
    animation-timing-function: ${(props) => props.timingFunc || defaultTimingFunc};
    animation-iteration-count: ${(props) => props.iterations || defaultIterations};
    animation-fill-mode: ${(props) => props.fillMode || defaultFillMode};
    animation-delay: ${(props) => props.delayMs || defaultDelayMs}ms;
  `;
    // @ts-ignore
    const styledComponent = typeof component === 'string' ? styled__default['default'][component] : styled__default['default'](component);
    const DefaultComponent = styledComponent `${componentCss}`;
    // Configure a function component
    const Animation = React__default['default'].forwardRef(({ active, style, onActive, onComplete, exitOnComplete, parentAnimation, childAnimation, inline, children, ...props }, ref) => {
        // Initialize state and constants
        exitOnComplete = exitOnComplete !== undefined ? !!exitOnComplete : !!defaultExitOnComplete;
        const isActiveInitialState = active !== undefined ? !!active : !!defaultActive || props.delayMs === 0;
        const durationMs = props.durationMs || defaultDurationMs;
        const iterations = props.iterations || defaultIterations;
        const [isActive, setIsActive] = React__default['default'].useState(isActiveInitialState);
        const [isComplete, setIsComplete] = React__default['default'].useState(false);
        const [forceRemount, setForceRemount] = React__default['default'].useState(false);
        const [keyframeProps, setKeyframeProps] = React__default['default'].useState();
        const childRef = React__default['default'].useRef(null);
        // Set style from `inline` prop if exists
        style = style || {};
        if (inline) {
            style.display = 'inline-block';
        }
        // Pass element dimensions to keyframes function (if using a keyframe function)
        React__default['default'].useEffect(() => {
            if (typeof keyframes === 'function') {
                if (childRef.current && childRef.current) {
                    const el = childRef.current.firstElementChild || childRef.current;
                    const domRect = el.getBoundingClientRect();
                    const computed = getComputedStyle(el);
                    const { marginRight, marginBottom, marginLeft } = computed;
                    const margins = [marginRight, marginBottom, marginLeft];
                    const [mr, mb, ml] = margins.map((m) => parseFloat(m.replace('px', '')));
                    const widthPx = domRect.width + mb + ml;
                    const heightPx = domRect.height + mb;
                    console.log({ widthPx, heightPx, domRect, mr, mb });
                    setKeyframeProps({ widthPx, heightPx });
                }
            }
        }, [keyframes, childRef.current]);
        // Add "reset" and "activate" methods to the forwarded ref
        React__default['default'].useImperativeHandle(ref, () => ({
            reset() {
                setIsComplete(false);
                setIsActive(false);
                setForceRemount(true);
            },
            activate() {
                setIsActive(true);
            },
        }));
        // Detect if active prop changes from false to true and update state
        React__default['default'].useEffect(() => {
            !isActive && active && setIsActive(true);
        }, [active]);
        // Call onActive function when animation first becomes active
        React__default['default'].useEffect(() => {
            isActive && onActive && onActive();
        }, [isActive]);
        // Reset forceRemount to false if triggered
        React__default['default'].useEffect(() => {
            forceRemount && setForceRemount(false);
        }, [forceRemount]);
        // Detect when animation is complete then set isComplete and call onComplete
        React__default['default'].useEffect(() => {
            let timeoutId;
            if (isActive) {
                if (typeof iterations === 'number' && typeof durationMs === 'number') {
                    timeoutId = setTimeout(() => {
                        setIsComplete(true);
                        onComplete && onComplete();
                        // @ts-ignore
                    }, durationMs * iterations);
                }
            }
            // Teardown
            return () => {
                timeoutId && clearTimeout(timeoutId);
            };
        }, [durationMs, iterations, isActive]);
        // Detect when a delayed animation becomes active and set isActive
        React__default['default'].useEffect(() => {
            let timeoutId;
            if (!isActive && typeof props.delayMs === 'number') {
                timeoutId = setTimeout(() => {
                    setIsActive(true);
                }, props.delayMs);
            }
            // Teardown
            return () => {
                timeoutId && clearTimeout(timeoutId);
            };
        }, [isActive, props.delayMs]);
        let Component = DefaultComponent;
        // Insert a child animation if one is defined
        if (childAnimation) {
            Component = React__default['default'].useMemo(() => {
                const _Component = Component;
                const ChildAnimation = childAnimation;
                return (props) => (React__default['default'].createElement(_Component, Object.assign({}, props),
                    React__default['default'].createElement(ChildAnimation, Object.assign({}, props), children)));
            }, []);
        }
        // Wrap with a parent animation if one is defined
        if (parentAnimation) {
            Component = React__default['default'].useMemo(() => {
                const _Component = Component;
                const ParentAnimation = parentAnimation;
                return (props) => (React__default['default'].createElement(ParentAnimation, Object.assign({}, props),
                    React__default['default'].createElement(_Component, Object.assign({}, props), children)));
            }, []);
        }
        // Force the Component to rerender if forceRemount is true
        if (forceRemount) {
            return React__default['default'].createElement(React__default['default'].Fragment, null, children);
        }
        // If animation exits on complete, remove from DOM on finish
        if (isComplete && exitOnComplete) {
            return React__default['default'].createElement(React__default['default'].Fragment, null);
        }
        // Else render the animated component
        return (React__default['default'].createElement(Component, Object.assign({}, props, keyframeProps, { style: style, ref: childRef }), children));
    });
    return Animation;
};

/**
 * Generic animation component that wraps the animation factory for full customization.
 *
 * WARNING: Even though this is memoized, creating a styled-component from inside a function component is unsupported
 * by styled-components and they will log a violation to the console. Use this component at your own risk. If in doubt,
 * use animationFactory to safely create a reusable animated component.
 */
const Animation$g = ({ keyframes, component, children, ...props }) => {
    const AnimatedComponent = React__default['default'].useMemo(() => {
        return animationFactory({ keyframes, component });
    }, [keyframes]);
    return React__default['default'].createElement(AnimatedComponent, Object.assign({}, props), children);
};

const Animation$f = animationFactory({
    keyframes: fadeIn,
    defaultDurationMs: config.durationMs.medium,
    defaultTimingFunc: config.timingFunc.linear,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.enterAnimationDefault,
});

const Animation$e = animationFactory({
    keyframes: fadeOut,
    defaultDurationMs: config.durationMs.medium,
    defaultTimingFunc: config.timingFunc.linear,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.exitAnimationDefault,
    defaultExitOnComplete: true,
    defaultActive: false,
});

const Fade = React__default['default'].forwardRef(({ out, ...props }, ref) => {
    if (out) {
        return React__default['default'].createElement(Animation$e, Object.assign({}, props, { ref: ref }));
    }
    else {
        return React__default['default'].createElement(Animation$f, Object.assign({}, props, { ref: ref }));
    }
});

const Animation$d = animationFactory({
    keyframes: rotateCcw,
    defaultDurationMs: config.durationMs.slow,
    defaultTimingFunc: config.timingFunc.linear,
    defaultIterations: config.iterations.infinite,
});

const Animation$c = animationFactory({
    keyframes: rotateCw,
    defaultDurationMs: config.durationMs.slow,
    defaultTimingFunc: config.timingFunc.linear,
    defaultIterations: config.iterations.infinite,
});

const Rotate = React__default['default'].forwardRef(({ ccw, ...props }, ref) => {
    if (ccw) {
        return React__default['default'].createElement(Animation$d, Object.assign({}, props, { ref: ref }));
    }
    return React__default['default'].createElement(Animation$c, Object.assign({}, props, { ref: ref }));
});

const Animation$b = animationFactory({
    keyframes: slideInDown,
    defaultDurationMs: config.durationMs.fast,
    defaultTimingFunc: config.timingFunc.easeOut,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.enterAnimationDefault,
});

const Animation$a = animationFactory({
    keyframes: slideInUp,
    defaultDurationMs: config.durationMs.fast,
    defaultTimingFunc: config.timingFunc.easeOut,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.enterAnimationDefault,
});

const Animation$9 = animationFactory({
    keyframes: slideInLeft,
    defaultDurationMs: config.durationMs.fast,
    defaultTimingFunc: config.timingFunc.easeOut,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.enterAnimationDefault,
});

const Animation$8 = animationFactory({
    keyframes: slideInRight,
    defaultDurationMs: config.durationMs.fast,
    defaultTimingFunc: config.timingFunc.easeOut,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.enterAnimationDefault,
});

const Animation$7 = animationFactory({
    keyframes: slideOutDown,
    defaultDurationMs: config.durationMs.fast,
    defaultTimingFunc: config.timingFunc.easeIn,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.exitAnimationDefault,
    defaultExitOnComplete: true,
    defaultActive: false,
});

const Animation$6 = animationFactory({
    keyframes: slideOutUp,
    defaultDurationMs: config.durationMs.fast,
    defaultTimingFunc: config.timingFunc.easeIn,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.exitAnimationDefault,
    defaultExitOnComplete: true,
    defaultActive: false,
});

const Animation$5 = animationFactory({
    keyframes: slideOutLeft,
    defaultDurationMs: config.durationMs.fast,
    defaultTimingFunc: config.timingFunc.easeIn,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.exitAnimationDefault,
    defaultExitOnComplete: true,
    defaultActive: false,
});

const Animation$4 = animationFactory({
    keyframes: slideOutRight,
    defaultDurationMs: config.durationMs.fast,
    defaultTimingFunc: config.timingFunc.easeIn,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.exitAnimationDefault,
    defaultExitOnComplete: true,
    defaultActive: false,
});

const Animation$3 = animationFactory({
    keyframes: wipeInX,
    defaultDurationMs: config.durationMs.medium,
    defaultTimingFunc: config.timingFunc.easeIn,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.enterAnimationDefault,
});

const Animation$2 = animationFactory({
    keyframes: wipeInY,
    defaultDurationMs: config.durationMs.medium,
    defaultTimingFunc: config.timingFunc.easeIn,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.enterAnimationDefault,
});

const Animation$1 = animationFactory({
    keyframes: wipeOutX,
    defaultDurationMs: config.durationMs.medium,
    defaultTimingFunc: config.timingFunc.easeOut,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.exitAnimationDefault,
    defaultExitOnComplete: true,
    defaultActive: false,
});

const Animation = animationFactory({
    keyframes: wipeOutY,
    defaultDurationMs: config.durationMs.medium,
    defaultTimingFunc: config.timingFunc.easeOut,
    defaultIterations: config.iterations.once,
    defaultFillMode: config.fillModes.exitAnimationDefault,
    defaultExitOnComplete: true,
    defaultActive: false,
});

const Slide = React__default['default'].forwardRef(({ out, up, right, down, left, direction, fade, wipe, children, ...props }, ref) => {
    let SlideComponent;
    let FadeComponent;
    let WipeComponent;
    // Slide in
    SlideComponent = Animation$b;
    FadeComponent = Animation$f;
    WipeComponent = Animation$2;
    if (right || direction === 'right') {
        SlideComponent = Animation$8;
        WipeComponent = Animation$3;
    }
    if (up || direction === 'up') {
        SlideComponent = Animation$a;
    }
    if (left || direction === 'left') {
        SlideComponent = Animation$9;
        WipeComponent = Animation$3;
    }
    // Slide out
    if (out) {
        FadeComponent = Animation$e;
        SlideComponent = Animation$6;
        WipeComponent = Animation;
        if (right || direction === 'right') {
            SlideComponent = Animation$4;
            WipeComponent = Animation$1;
        }
        if (down || direction === 'down') {
            SlideComponent = Animation$7;
        }
        if (left || direction === 'left') {
            SlideComponent = Animation$5;
            WipeComponent = Animation$1;
        }
    }
    if (wipe && fade) {
        return (React__default['default'].createElement(WipeComponent, Object.assign({}, props, { ref: ref }),
            React__default['default'].createElement(FadeComponent, Object.assign({}, props),
                React__default['default'].createElement(SlideComponent, Object.assign({}, props), children))));
    }
    if (wipe) {
        return (React__default['default'].createElement(WipeComponent, Object.assign({}, props, { ref: ref }),
            React__default['default'].createElement(SlideComponent, Object.assign({}, props), children)));
    }
    if (fade) {
        return (React__default['default'].createElement(FadeComponent, Object.assign({}, props, { ref: ref }),
            React__default['default'].createElement(SlideComponent, Object.assign({}, props), children)));
    }
    return (React__default['default'].createElement(SlideComponent, Object.assign({ ref: ref }, props), children));
});

exports.Animation = Animation$g;
exports.Fade = Fade;
exports.FadeIn = Animation$f;
exports.FadeOut = Animation$e;
exports.Rotate = Rotate;
exports.RotateCcw = Animation$d;
exports.RotateCw = Animation$c;
exports.Slide = Slide;
exports.SlideInDown = Animation$b;
exports.SlideInLeft = Animation$9;
exports.SlideInRight = Animation$8;
exports.SlideInUp = Animation$a;
exports.SlideOutDown = Animation$7;
exports.SlideOutLeft = Animation$5;
exports.SlideOutRight = Animation$4;
exports.SlideOutUp = Animation$6;
exports.animationFactory = animationFactory;
exports.fadeIn = fadeIn;
exports.fadeOut = fadeOut;
exports.globals = config;
exports.rotateCcw = rotateCcw;
exports.rotateCw = rotateCw;
exports.slideInDown = slideInDown;
exports.slideInLeft = slideInLeft;
exports.slideInRight = slideInRight;
exports.slideInUp = slideInUp;
exports.slideOutDown = slideOutDown;
exports.slideOutLeft = slideOutLeft;
exports.slideOutRight = slideOutRight;
exports.slideOutUp = slideOutUp;
exports.wipeInX = wipeInX;
exports.wipeInY = wipeInY;
exports.wipeOutX = wipeOutX;
exports.wipeOutY = wipeOutY;
//# sourceMappingURL=index.js.map
